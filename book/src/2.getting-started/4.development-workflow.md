# ðŸ”„ Development Workflow

This guide covers best practices for developing Teams AI SDK applications, including common development tasks, testing strategies, and deployment considerations.

## Development Cycle

A typical development workflow with Teams AI SDK follows these steps:

1. **Plan**: Determine what functionality you need to implement
2. **Code**: Write the necessary code in your project
3. **Test**: Run your application locally and test with DevTools
4. **Refine**: Iterate based on testing results
5. **Deploy**: Deploy your application to a production environment

Let's explore each of these steps in more detail.

## Common Development Tasks

### Adding Activity Handlers

The most common task in Teams AI SDK development is adding handlers for different types of activities:

```typescript
// Handle text messages
app.on('message', async ({ send, activity }) => {
  await send(`You said: "${activity.text}"`);
});

// Handle when users join the conversation
app.on('conversationUpdate', async ({ activity, send }) => {
  if (activity.membersAdded?.some(m => m.id !== activity.recipient?.id)) {
    await send('Welcome to the conversation!');
  }
});

// Handle specific events
app.on('event', async ({ activity, send }) => {
  if (activity.name === 'customEvent') {
    await send('Received a custom event!');
  }
});
```

### Creating Adaptive Cards

To create interactive experiences, you can use Adaptive Cards:

```typescript
import { AdaptiveCard, TextBlock, ActionSet, SubmitAction } from '@microsoft/teams.cards';

app.on('message', async ({ send, activity }) => {
  if (activity.text === 'show card') {
    const card = new AdaptiveCard()
      .addItem(new TextBlock('Hello from Adaptive Card!').size('large'))
      .addItem(new ActionSet().addAction(
        new SubmitAction('Click Me').data({ action: 'buttonClicked' })
      ));
    
    await send({ attachments: [card] });
  }
});

// Handle card actions
app.on('invoke', async ({ activity, send }) => {
  if (activity.name === 'adaptiveCard/action') {
    const data = activity.value?.action?.data;
    if (data?.action === 'buttonClicked') {
      await send('You clicked the button!');
    }
  }
});
```

### Adding Middleware

Middleware allows you to process activities before they reach your handlers:

```typescript
// Authentication middleware
app.use(async (context, next) => {
  // Check authentication
  if (!isAuthenticated(context.activity)) {
    await context.send('You are not authorized to use this bot.');
    return;
  }
  
  // Continue to next middleware or handler
  await next();
});

// Logging middleware
app.use(async (context, next) => {
  const start = Date.now();
  context.log.info(`Processing activity: ${context.activity.type}`);
  
  await next();
  
  const duration = Date.now() - start;
  context.log.info(`Processed activity in ${duration}ms`);
});
```

### Integrating with External Services

You can integrate with external services like databases or APIs:

```typescript
import { MongoClient } from 'mongodb';

// Initialize database connection
const client = new MongoClient(process.env.MONGODB_URI || 'mongodb://localhost:27017');
let db: any;

(async () => {
  await client.connect();
  db = client.db('myBotDb');
  console.log('Connected to database');
})();

// Use database in handlers
app.on('message', async ({ send, activity }) => {
  if (activity.text === 'stats') {
    // Query database
    const stats = await db.collection('stats').findOne({ userId: activity.from?.id });
    
    await send(`Your stats: ${JSON.stringify(stats)}`);
  }
});
```

## Testing Strategies

### Local Testing with DevTools

As covered in the [Running Your App](./3.running-your-app.md) guide, the integrated DevTools provide a powerful way to test your application locally.

### Unit Testing

For unit testing individual components, you can use Jest or another testing framework:

```typescript
// handlers.ts
export function createMessageHandler() {
  return async ({ send, activity }: any) => {
    await send(`You said: "${activity.text}"`);
  };
}

// handlers.test.ts
import { createMessageHandler } from './handlers';

describe('Message Handler', () => {
  it('should echo back the message text', async () => {
    const mockSend = jest.fn();
    const mockContext = {
      send: mockSend,
      activity: { text: 'hello' }
    };
    
    const handler = createMessageHandler();
    await handler(mockContext);
    
    expect(mockSend).toHaveBeenCalledWith('You said: "hello"');
  });
});
```

### Integration Testing

For testing the entire application flow:

```typescript
import { App } from '@microsoft/teams.apps';
import { createTestClient } from '@microsoft/teams.dev/testing';

describe('Bot Integration Tests', () => {
  let app: App;
  let testClient: any;
  
  beforeEach(() => {
    app = new App();
    app.on('message', async ({ send, activity }) => {
      await send(`You said: "${activity.text}"`);
    });
    
    testClient = createTestClient(app);
  });
  
  it('should respond to messages', async () => {
    const response = await testClient.sendMessage('hello');
    expect(response).toEqual('You said: "hello"');
  });
});
```

## Using Turbo for Monorepo Development

If you're developing multiple related applications or packages, you can use Turbo to manage a monorepo:

### Setting Up a Monorepo

1. Create a root package.json:
   ```json
   {
     "name": "my-teams-apps",
     "private": true,
     "workspaces": ["apps/*", "packages/*"],
     "scripts": {
       "build": "turbo run build",
       "dev": "turbo run dev",
       "lint": "turbo run lint",
       "test": "turbo run test"
     },
     "devDependencies": {
       "turbo": "^1.10.0"
     }
   }
   ```

2. Create a turbo.json configuration:
   ```json
   {
     "$schema": "https://turbo.build/schema.json",
     "pipeline": {
       "build": {
         "dependsOn": ["^build"],
         "outputs": ["dist/**"]
       },
       "dev": {
         "cache": false,
         "persistent": true
       },
       "lint": {},
       "test": {
         "dependsOn": ["build"]
       }
     }
   }
   ```

3. Organize your projects:
   ```
   my-teams-apps/
   â”œâ”€â”€ apps/
   â”‚   â”œâ”€â”€ bot-app/
   â”‚   â””â”€â”€ tab-app/
   â”œâ”€â”€ packages/
   â”‚   â”œâ”€â”€ shared-ui/
   â”‚   â””â”€â”€ common-utils/
   â”œâ”€â”€ package.json
   â””â”€â”€ turbo.json
   ```

### Running Commands

To run commands across all projects:

```sh
# Build all projects
npm run build

# Run development servers for all projects
npm run dev

# Run tests for all projects
npm run test
```

To run commands for a specific project:

```sh
# Run dev server for just the bot-app
npm run dev --workspace=apps/bot-app

# Build just the shared-ui package
npm run build --workspace=packages/shared-ui
```

## Deployment Considerations

### Environment Variables

For production deployment, ensure you have the correct environment variables set:

1. Create a `.env.production` file with production values
2. Ensure sensitive values are not committed to source control
3. Configure your hosting platform with the necessary environment variables

### Hosting Options

Teams AI SDK applications can be hosted on various platforms:

- **Azure App Service**: Microsoft's recommended hosting for Teams applications
- **Azure Functions**: For serverless deployment
- **Azure Container Apps**: For containerized applications
- **Other Cloud Providers**: AWS, Google Cloud, etc.
- **On-premises**: Your own servers

### Deployment Process

A typical deployment process includes:

1. Build your application: `npm run build`
2. Set up environment variables for production
3. Deploy the built application to your hosting platform
4. Register your bot/application with the Microsoft Teams platform
5. Test the deployed application in Teams

## Best Practices

### Follow Teams.TS Principles

As outlined in the project's core principles:

1. **Low Dependency**: Minimize external dependencies to avoid compatibility issues
2. **Unopinionated Design**: Use Teams AI SDK as a flexible toolkit, not a rigid framework
3. **Tool Consolidation**: Leverage the integrated tools in the Teams AI SDK ecosystem

### Code Organization

- Keep related functionality together
- Use clear, descriptive names for files and functions
- Separate business logic from activity handlers
- Use TypeScript interfaces for complex data structures

### Error Handling

Implement robust error handling:

```typescript
app.on('message', async ({ send, activity, log }) => {
  try {
    // Potentially error-prone code
    const result = await someExternalService.process(activity.text);
    await send(`Result: ${result}`);
  } catch (error) {
    log.error('Error processing message:', error);
    await send('Sorry, I encountered an error processing your request.');
  }
});
```

### Logging

Use the built-in logging system with appropriate levels:

```typescript
app.on('message', async ({ log, activity, send }) => {
  log.debug('Received message:', activity);
  log.info(`User ${activity.from?.name} sent: ${activity.text}`);
  
  if (someCondition) {
    log.warn('Unusual condition detected');
  }
  
  try {
    // Process message
  } catch (error) {
    log.error('Failed to process message:', error);
  }
});
```

## What's Next?

Now that you understand the development workflow:

1. **Explore specific features** like AI integration, Adaptive Cards, or authentication
2. **Build more complex applications** by combining different Teams AI SDK packages
3. **Deploy your application** to a production environment

Check out the next guide on [Next Steps](./5.next-steps.md) for guidance on where to go from here based on your specific needs.
